# Cheatsheet

> 코딩테스트를 진행할 때 문제에서 키워드를 찾고, 해당 키워드에 대한 알고리즘이나 자료구조를 떠올리는 것이 중요하다.

## 자료구조
### 배열
- 메모리 상에 원소를 연속적으로 저장하는 자료구조이다.
- 배열의 성질
  - 특정 인덱스 값을 확인, 변경하는 시간복잡도는 `O(1)`이다.
  - 끝에 원소를 추가하는 시간복잡도는 `O(1)`이다.
  - 마지막 원소를 삭제하는 시간복잡도는 `O(1)`이다.
  - 특정 인덱스에 값을 추가, 삭제하는 시간복잡도는 `O(n)`이다.
- 최대한 적은 시간복잡도로 문제를 해결한다.

### 연결 리스트
- 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조이다.
- 연결 리스트의 성질
  - 임의의 위치에 있는 원소를 확인, 변경하는 시간복잡도는 `O(n)`이다.
  - 임의의 위치에 원소를 추가, 제거하는 시간복잡도는 `O(1)`이다.
- 연결 리스트의 종류
  - 단일 연결 리스트
  - 이중 연결 리스트
  - 원형 연결 리스트
- 메모장과 같은 텍스트 에디터에서 연결 리스트를 사용할 수 있다. (커서를 옮기고 텍스트를 추가, 삭제하는 기능)
- 즉, 임의의 위치에 원소를 추가, 제거하는 연산을 많이 해야 할 경우 연결 리스트를 사용할 수 있다.

> Q : 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 List의 길이를 효율적으로 구하는 방법?<br />
A : 동일한 노드가 나올 때까지 계속 다음 노드로 순회하면서 카운트한다

> Q : 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때, 만나는 지점을 구하는 방법?<br />
A : 모든 노드를 저장하지 말고, 먼저 둘의 길이 차이를 구한 다음 더 긴 쪽을 둘의 차이만큼 앞으로 먼저 이동시켜놓은 뒤에, 두 연결 리스트의 시작점부터 순회하면서 동일한 노드가 나올 때까지 순회한다. 공간복잡도 `O(1)`, 시간복잡도 `O(A+B)`

> Q : 주어진 연결 리스트 안에 사이클이 있는지 판단하는 방법?<br />
A : 두 개의 포인터를 사용한다. 한 개의 포인터는 한 번에 한 칸씩, 다른 한 개의 포인터는 한 번에 두 칸씩 이동하면서 순회한다. 만약 사이클이 있다면, 두 번째 포인터가 첫 번째 포인터를 한 바퀴 돌아서 다시 만나게 된다. 사이클이 없다면 두 포인터가 만나지 못하고 연결 리스트의 끝에 도달한다. 공간복잡도 `O(1)`

### 스택
- LIFO(Last In First Out) 구조를 가지는 자료구조이다.
- 원소의 추가, 삭제 시간복잡도는 `O(1)`이다.
- 제일 상단의 원소를 확인하는 시간복잡도는 `O(1)`이다.

### 큐
- FIFO(First In First Out) 구조를 가지는 자료구조이다.
- 원소의 추가, 제거 시간복잡도는 `O(1)`이다.
- 제일 앞, 뒤의 원소 확인 시간복잡도는 `O(1)`이다.

### 덱
- Double Ended Queue
- 양쪽 끝에서 원소의 추가, 제거가 가능한 자료구조이다.
- 원소의 추가, 제거 시간복잡도는 `O(1)`이다.
- 제일 앞, 뒤의 원소 확인 시간복잡도는 `O(1)`이다.

## 알고리즘
### BFS
- 너비 우선 탐색
- 과정
  1. 시작하는 칸을 큐에 넣고 방문했다는 표시 남김
  2. 큐에서 원소를 꺼내어 해당 원소의 칸에 상하좌우로 인접한 칸에 대해 3번 진행
  3. 해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
  4. 큐가 빌 때까지 2~3번을 반복
- 모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 `O(N)`
> **💡 BFS 문제 풀 때 체크하기!**
> 1. 입력값 변환을 잘 했는지 확인한다 (정수형 혹은 문자열인지 확인)
> 2. 시작점 방문 표시를 남긴다
> 3. 큐에 넣을 때 방문 표시를 한다.
> 4. 범위를 벗어나는지 체크한다