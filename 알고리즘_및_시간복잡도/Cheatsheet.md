# Cheatsheet

> 코딩테스트를 진행할 때 문제에서 키워드를 찾고, 해당 키워드에 대한 알고리즘이나 자료구조를 떠올리는 것이 중요하다.

## 자료구조
### 배열
- 메모리 상에 원소를 연속적으로 저장하는 자료구조이다.
- 배열의 성질
  - 특정 인덱스 값을 확인, 변경하는 시간복잡도는 `O(1)`이다.
  - 끝에 원소를 추가하는 시간복잡도는 `O(1)`이다.
  - 마지막 원소를 삭제하는 시간복잡도는 `O(1)`이다.
  - 특정 인덱스에 값을 추가, 삭제하는 시간복잡도는 `O(n)`이다.
- 최대한 적은 시간복잡도로 문제를 해결한다.

### 연결 리스트
- 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조이다.
- 연결 리스트의 성질
  - 임의의 위치에 있는 원소를 확인, 변경하는 시간복잡도는 `O(n)`이다.
  - 임의의 위치에 원소를 추가, 제거하는 시간복잡도는 `O(1)`이다.
- 연결 리스트의 종류
  - 단일 연결 리스트
  - 이중 연결 리스트
  - 원형 연결 리스트
- 메모장과 같은 텍스트 에디터에서 연결 리스트를 사용할 수 있다. (커서를 옮기고 텍스트를 추가, 삭제하는 기능)
- 즉, 임의의 위치에 원소를 추가, 제거하는 연산을 많이 해야 할 경우 연결 리스트를 사용할 수 있다.

> Q : 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 List의 길이를 효율적으로 구하는 방법?<br />
A : 동일한 노드가 나올 때까지 계속 다음 노드로 순회하면서 카운트한다

> Q : 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때, 만나는 지점을 구하는 방법?<br />
A : 모든 노드를 저장하지 말고, 먼저 둘의 길이 차이를 구한 다음 더 긴 쪽을 둘의 차이만큼 앞으로 먼저 이동시켜놓은 뒤에, 두 연결 리스트의 시작점부터 순회하면서 동일한 노드가 나올 때까지 순회한다. 공간복잡도 `O(1)`, 시간복잡도 `O(A+B)`

> Q : 주어진 연결 리스트 안에 사이클이 있는지 판단하는 방법?<br />
A : 두 개의 포인터를 사용한다. 한 개의 포인터는 한 번에 한 칸씩, 다른 한 개의 포인터는 한 번에 두 칸씩 이동하면서 순회한다. 만약 사이클이 있다면, 두 번째 포인터가 첫 번째 포인터를 한 바퀴 돌아서 다시 만나게 된다. 사이클이 없다면 두 포인터가 만나지 못하고 연결 리스트의 끝에 도달한다. 공간복잡도 `O(1)`

### 스택
- LIFO(Last In First Out) 구조를 가지는 자료구조이다.
- 원소의 추가, 삭제 시간복잡도는 `O(1)`이다.
- 제일 상단의 원소를 확인하는 시간복잡도는 `O(1)`이다.

### 큐
- FIFO(First In First Out) 구조를 가지는 자료구조이다.
- 원소의 추가, 제거 시간복잡도는 `O(1)`이다.
- 제일 앞, 뒤의 원소 확인 시간복잡도는 `O(1)`이다.

### 덱
- Double Ended Queue
- 양쪽 끝에서 원소의 추가, 제거가 가능한 자료구조이다.
- 원소의 추가, 제거 시간복잡도는 `O(1)`이다.
- 제일 앞, 뒤의 원소 확인 시간복잡도는 `O(1)`이다.