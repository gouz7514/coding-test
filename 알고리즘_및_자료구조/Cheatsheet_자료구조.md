> 코딩테스트를 진행할 때 문제에서 키워드를 찾고, 해당 키워드에 대한 알고리즘이나 자료구조를 떠올리는 것이 중요하다.

# 자료구조
### 배열
- 메모리 상에 원소를 연속적으로 저장하는 자료구조이다.
- 배열의 성질
  - 특정 인덱스 값을 확인, 변경하는 시간복잡도는 `O(1)`이다.
  - 끝에 원소를 추가하는 시간복잡도는 `O(1)`이다.
  - 마지막 원소를 삭제하는 시간복잡도는 `O(1)`이다.
  - 특정 인덱스에 값을 추가, 삭제하는 시간복잡도는 `O(n)`이다.
- 최대한 적은 시간복잡도로 문제를 해결한다.

### 연결 리스트
- 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조이다.
- 연결 리스트의 성질
  - 임의의 위치에 있는 원소를 확인, 변경하는 시간복잡도는 `O(n)`이다.
  - 임의의 위치에 원소를 추가, 제거하는 시간복잡도는 `O(1)`이다.
- 연결 리스트의 종류
  - 단일 연결 리스트
  - 이중 연결 리스트
  - 원형 연결 리스트
- 메모장과 같은 텍스트 에디터에서 연결 리스트를 사용할 수 있다. (커서를 옮기고 텍스트를 추가, 삭제하는 기능)
- 즉, 임의의 위치에 원소를 추가, 제거하는 연산을 많이 해야 할 경우 연결 리스트를 사용할 수 있다.

> Q : 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 List의 길이를 효율적으로 구하는 방법?<br />
A : 동일한 노드가 나올 때까지 계속 다음 노드로 순회하면서 카운트한다

> Q : 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때, 만나는 지점을 구하는 방법?<br />
A : 모든 노드를 저장하지 말고, 먼저 둘의 길이 차이를 구한 다음 더 긴 쪽을 둘의 차이만큼 앞으로 먼저 이동시켜놓은 뒤에, 두 연결 리스트의 시작점부터 순회하면서 동일한 노드가 나올 때까지 순회한다. 공간복잡도 `O(1)`, 시간복잡도 `O(A+B)`

> Q : 주어진 연결 리스트 안에 사이클이 있는지 판단하는 방법?<br />
A : 두 개의 포인터를 사용한다. 한 개의 포인터는 한 번에 한 칸씩, 다른 한 개의 포인터는 한 번에 두 칸씩 이동하면서 순회한다. 만약 사이클이 있다면, 두 번째 포인터가 첫 번째 포인터를 한 바퀴 돌아서 다시 만나게 된다. 사이클이 없다면 두 포인터가 만나지 못하고 연결 리스트의 끝에 도달한다. 공간복잡도 `O(1)`

### 스택
- LIFO(Last In First Out) 구조를 가지는 자료구조이다.
- 원소의 추가, 삭제 시간복잡도는 `O(1)`이다.
- 제일 상단의 원소를 확인하는 시간복잡도는 `O(1)`이다.

### 큐
- FIFO(First In First Out) 구조를 가지는 자료구조이다.
- 원소의 추가, 제거 시간복잡도는 `O(1)`이다.
- 제일 앞, 뒤의 원소 확인 시간복잡도는 `O(1)`이다.

### 덱
- Double Ended Queue
- 양쪽 끝에서 원소의 추가, 제거가 가능한 자료구조이다.
- 원소의 추가, 제거 시간복잡도는 `O(1)`이다.
- 제일 앞, 뒤의 원소 확인 시간복잡도는 `O(1)`이다.

### 힙
- 완전 이진 트리의 일종으로, 우선순위 큐를 위해 만들어진 자료구조이다.
- 최댓값, 최솟값을 빠르게 찾기 위해 고안된 자료구조이다.
- 힙의 종류
  - 최대 힙 : 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리
  - 최소 힙 : 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리
- 원소의 추가, 제거 시간복잡도는 `O(logN)`이다.
> **💡 `O(logN)`인 이유**
> 힙은 완전 이진 트리이므로 높이가 `logN`이다.
> 원소 추가와 제거 연산은 힙 내에서 노드를 올바른 위치로 이동시키는 과정을 포함한다. 이 과정에서는 부모 노드와 자식 노드 사이의 비교 및 스왑 작업이 이루어진다.
> 이 과정은 힙의 높이에 비례한다. 따라서 시간복잡도는 `O(logN)`이다.

### 우선순위 큐
- 우선순위가 가장 높은 원소가 가장 먼저 나오는 자료구조이다.
- 원소의 추가, 제거 시간복잡도는 `O(logN)`이다.

### 그래프
- 정점(V)과 간선(E)으로 이루어진 자료구조이다.
- 방향이 있는 그래프(방향 그래프)와 방향이 없는 그래프(무방향 그래프)로 나뉜다.
- 사이클이 있을 수 있다 (사이클 : 시작점과 끝점이 같은 경로)
- 그래프를 코드로 나타내는 두 가지 방법:
1. 인접 행렬 이용
    - 그래프의 각 노드를 인덱스로 표현하는 2차원 배열을 사용하는 방법이다.
    - 노드 i와 노드 j가 연결되어 있는지 알고 싶다면 `adj[i][j]`를 확인하면 되므로, 시간복잡도는 `O(1)`이다.
    - 노드 i에 연결된 모든 노드들에 방문하고 싶은 경우 adj[i][1]부터 adj[i][N]까지 확인하면 되므로 시간복잡도는 `O(V)`이다.
    - 그래프의 모든 간선의 수를 알아내려면 `O(V^2)`의 시간이 소요된다.
    - 노드의 개수에 비해 간선의 개수가 훨씬 적다면, 특정 노드와 연결된 노드들이 몇 번 노드인지 확인하기 위해 모든 노드를 확인해야 하는 단점이 있다. (이를 보완하기 위해 인접 리스트 사용)
    - **두 점의 연결여부를 자주 확인할 때, E가 V^2에 가까울 때** 사용하면 좋다.
2. 인접 리스트 이용
    - 그래프의 각 노드에 인접한 노드들을 연결리스트로 표현하는 방법이다.
    - 노드의 개수만큼 인접리스트가 존재하며, 각각의 인접리스트에는 인접한 노드 정보가 저장된다.
    - 노드 i와 노드 j가 연결되어 있는지 알고 싶다면, 한 정점에 대해 자신과 연결된 모든 정점을 확인해야 하므로 `O(min(degree(i), degree(j)))`의 시간복잡도를 갖는다.
    - 노드 i와 연결된 모든 노드를 확인하는 시간 복잡도는 `O(degree(i))`이다.
    - **특정 정점에 연결된 모든 정점을 자주 확인할 때, E가 V^2보다 훨씬 작을 때** 사용하면 좋다. 

> **💡 그래프 문제 풀 때 체크하기!**<br />
> 추가적인 조건이 지정되지 않는다면, 그래프가 분리되어 있거나, 같은 간선이 여러 개 있거나, 루프가 있을 수도 있다.<br />
> 일반적인 그래프 문제에서 두 정점이 연결되어 있는지를 반복적으로 확인해야 하는 경우는 잘 없다.<br />
> 특정 정점에 연결된 모든 정점을 확인하는 작업이 반복적으로 등장하기 때문에, 인접 리스트에 익숙해지는 것이 좋다.<br />
> 다만, 플로이드 알고리즘처럼 인접 행렬을 사용해야 하는 경우도 있다.